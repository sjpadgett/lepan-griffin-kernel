
magic number for zimage   016f2818 
.word 0x016f2818 @ Magic numbers to help the loader ==0x24 offset
.word start @ absolute load/run zImage address 
.word _edata @ zImage end address

./packlinux ramdisk.img < ramdisk.conf

#To make kernel
export ARCH=arm
export CROSS_COMPILE=arm-eabi-
export PATH=$PATH:~/myandroid/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin

setenv ibootargs console=ttyS2,115200n8 androidboot.console=ttyS2 androidboot.mode=normal omap_vout_mod.video1_numbuffers=6 omap_vout_mod.vid1_static_vrfb_alloc=y androidboot.reason=charge earlyprintk

setenv bootargs console=ttyS2,115200n8 androidboot.console=ttyS2 androidboot.mode=normal omap_vout_mod.video1_numbuffers=6 omap_vout_mod.vid1_static_vrfb_alloc=y androidboot.reason=charge earlyprintk

setenv ibootargs console=ttyO2,115200n8 androidboot.console=ttyO2 androidboot.mode=normal omap_vout_mod.video1_numbuffers=6 omap_vout_mod.vid1_static_vrfb_alloc=y androidboot.reason=charge earlyprintk

mmc init;fatload mmc 0 81000000 zimage;
mmc init;fatload mmc 0 81000000 linux.ism
go 0x81000000

#To make wifi module
export KERNEL_DIR=~/android/sources/kernel
cd ~/myandroid/system/wlan/ti/sta_dk_4_0_4_32/

#Pull kernel config from running phone
adb pull /proc/config.gz ~/android/sources/kernel/
cd ~/android/sources/kernel/
gunzip config.gz

#Pull boot image from running phone
adb shell
cat /dev/mtd/mtd2 > /sdcard/running.img
exit
adb pull /sdcard/running.img /PATH TO PLACE BOOT IMAGE
cd *path-you-placed-the-image
cp running.img boot.img

#Locations
~/android/sources/kernel/arch/arm/boot/zImage <-----compiled kernel
~/myandroid/system/wlan/ti/sta_dk_4_0_4_32/wlan.ko <-----WiFi module

git archive -v master | (cd ../gen9-kernel/ && tar xf -)

make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage modules

# for .bash speedup compile
export CFLAGS="$CFLAGS -pipe"
export CXXFLAGS="$CXXFLAGS -pipe"

env | grep TARGET
echo "60000,1024/26/48/27,768/16/6/10" > /sys/devices/platform/omapdss/display0/timings 
cat /sys/devices/platform/omapdss/display0/timings
cat / dev / input / event *

..create image
mkdir sub
cp hello sub/init
cd sub
find . | cpio -o -H newc | gzip > ../initramfs_data.cpio.gz
cd ..
rm -rf sub

.... decompress
zcat initramfs_data.cpio.gz | cpio -i -d -H newc --no-absolute-filenames
... another create
find ./ | cpio -H newc -o > /your/location/initrd

Extracting Android’s YAFFS2 images

A YAFFS2 file is identied as a “VMS Alpha executable” by Linux.

user@computer:$ file ${SDK_ROOT}}/out/target/product/imx51_ccwmx51js/system.img
./out/target/product/imx51_ccwmx51js/system.img: VMS Alpha executable

Download unyaffs from the unyaffs Google Project Hosting.

user@computer:$ gcc -o unyaffs unyaffs.c
sudo chmod +x /complete/directory/path/to/unyaffs

Copy the YAFF2 img files to the same folder and extract them:

user@computer:$ ./unyaffs system.img
./unyaffs data.img
./unyaffs cache.img

Extracting JFFS2 images

Just for completion, here is how to extract a JFFS2 image.

user@computer:$ modprobe mtdblock
modprobe jffs2
modprobe mtdram total_size=65536 erase_size=256
mknod /tmp/mtdblock0 b 31 0
dd if=/pathtoimage/rootfs.jffs2 of=/tmp/mtdblock0
mount -t jffs2 /tmp/mtdblock0 /mnt

................  Modifying Android’s ramdisk image

To modify it, first copy it to your Linux machine and extract it as follows:
user@computer:$ mv ramdisk.img ramdisk.cpio.gz
gzip -d ramdisk.cpio.gz
cpio -i -F ramdisk.cpio

Make any changes you want to the extracted ramdisk.cpio, and remove the unneeded files. Recreate the ramdisk.cpio with command:
user@computer:$ cpio -i -t -F ../ramdisk.cpio | cpio -o -H newc -O ../ramdisk_new.cpio

dd if=NT_SDCardimg of=/dev/sdc bs=1M
./unpack-initramfs.sh ramdisk
dd if=recovery bs=1 skip=0 | zcat > recoveryz
od -A d -t x1 ramdisk | grep '1f 8b 08 00'

cpio -iv < ramdisk

unpacker -c griffin.ifw > griffin.conf

**************************************************************************************************************************
Here are the steps to open, edit and create a new ramdisk.img
Copy the ramdisk.img to your UBuntu (Linux) machine
Back up ramdisk.img and Create a temporary folder, say tmp
# cp ramdisk.img ramdisk.img.bkup
# mkdir tmp && cd tmp
Extract the ramdisk using the command below
# gunzip -c ../ramdisk.img | cpio -i
Modify the contents of tmp folder. The contents of tmp folder will get into the ramdisk.img
Modify the contents of file in tmp folder eg. init.rc
Recreate the ramdisk.cpio with command:
# find . | cpio -o -H newc | gzip > ../ramdisk.img
---------------------------------------------------------------------------------------------------------------------------------------------------------
Opening system.img for debugging using UNYAFFS tool
Using unyaffs
Note: This is valid for OMAP3. OMAP4 onwards we have moved to EXT4 file system, and this is no longer valid.
The Android OS makes use of a yaffs file system. You can download the unyaffs tool to extract the content of an Android image. There is a prebuildversion available at the Downloads section. Place the unyaffs tool inside the ~/bin directory so that the tool can be found because it is inside the PATH definition
When the unyaffs is downloaded, make sure it can be executed
# cd ~/bin
# chmod a+x unyaffs
To open the system.img you can use the command below
# mkdir tmp
# cd tmp 
# sudo ~/bin/unyaffs <path_to_system.img>
Once you do this you will see the files/folders below
app
bin
build.prop
etc
fonts
framework
lib
media
usr
xbin
*************************************************************************************************************************************************************